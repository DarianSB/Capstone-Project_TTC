---
title: "Project _TTC"
output: html_document
date: "2024-02-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
setwd("/Users/dariansajanbhakta/Documents/GitHub/Capstone-Project_TTC")
```

```{r}
# Load the readxl package
library(readxl)

# Read the Excel file
data2 <- read_excel("ttc-bus-delay-data-2021-23.xlsx")

# View the data (optional)
head(data2)
```

```{r}
str(data2)
```

```{r}
summary(data2)
```

```{r}
#Assigning Correct Data Type
data2$Day <- as.factor(data2$Day)
data2$Incident <- as.factor(data2$Incident)
data2$Direction <- as.factor(data2$Direction)
str(data2)
```

```{r}
# Identifying Presence of Missing Data
missing_values <- colSums(is.na(data2))

# Print the count of missing values for each column
print(missing_values)
```

```{r}
# HANDLING MISSING VALUES
#Subsetting rows where route is not provided
data2 <- subset(data2, !is.na(Route))
install.packages("DescTools")
library(DescTools)
library(dplyr)

# Replacing Direction attibutes with NA values based on route and its corresponding mode of direction
data2_filled <- data2 %>%
  group_by(Route) %>%
  mutate(Direction = ifelse(is.na(Direction), Mode(as.integer(Direction), na.rm = TRUE), Direction)) %>%
  ungroup()
missing_values <- colSums(is.na(data2_filled))

# Print the count of missing values for each column
print(missing_values)
```

```{r}
# OUTLIER ANALYSIS: Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled, aes(x = Incident, y = `Min Delay`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Incident", y = "Min Delay", title = "Boxplot of Min Delay by Incident")

```

```{r}
# Perform 'Winsorization' to Fix Outlier Issues: capping the outliers at a certain percentile. For example, all data points above the 95th percentile and below the 5th percentile
library(DescTools)

# Winsorize the 'Min Delay' column at the 5th and 95th percentiles for the entire data
data2_filled$Min_Delay_Winsorized <- Winsorize(data2_filled$`Min Delay`, probs = c(0.02, 0.98))

# Check the results
summary(data2_filled$Min_Delay_Winsorized)
```

```{r}
# OUTLIER ANALYSIS: Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled, aes(x = Incident, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Incident", y = "Min Delay", title = "Boxplot of Min Delay by Incident")
```

```{r}
#COUNT OF INCIDENTS
library(ggplot2)

# Create a bar graph with data labels and different bar colors
ggplot(data2_filled, aes(x = Incident, fill = Incident)) +
  geom_bar() +
  geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) +  # Add data labels
  scale_fill_discrete(name = "Incident") +  # Customize legend title
  labs(x = "Incident", y = "Count", title = "Count of Incidents") +
  theme(legend.position = "none")  # Hide legend (optional)


```

```{r}
# Load necessary library
library(dplyr)

# Count incidents for each type and calculate the percentage of the grand total
incident_type_counts <- data2_filled %>%
  group_by(Incident) %>%
  summarise(IncidentCount = n(), .groups = 'drop') %>%
  mutate(TotalIncidents = sum(IncidentCount), # Calculate the total number of incidents
         PercentageOfTotal = IncidentCount / TotalIncidents * 100) %>%
  arrange(desc(IncidentCount)) # Arrange by descending order of incident counts

# Print the results
print(incident_type_counts)
```

```{r}
# CLUBBING TIME-PERIODS
library(dplyr)

data2_filled_updated <- data2_filled %>%
  mutate(Hour = as.integer(substr(Time, 1, 2)),
         Minute = as.integer(substr(Time, 4, 5)),
         Time_Period = case_when(
           (Hour == 6 & Minute >= 0) | (Hour > 6 & Hour < 9) ~ "Morning Peak Hours",
           (Hour == 9 & Minute >= 0) | (Hour > 9 & Hour < 16) ~ "Off-Peak Hours",
           (Hour == 16 & Minute >= 0) | (Hour > 16 & Hour < 19) ~ "Afternoon Peak Hours",
           (Hour == 19 & Minute >= 0) | (Hour > 19 & Hour < 22) ~ "Evening Hours",
           TRUE ~ "Night Hours"
         ))
data2_filled_updated <- data2_filled_updated %>%
  select(-c(Hour, Minute))  # Remove the "Hour" and "Minute" columns
# Create a bar graph with data labels and different bar colors
ggplot(data2_filled_updated, aes(x = Time_Period, fill = Time_Period)) +
  geom_bar() +
  geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) +  # Add data labels
  scale_fill_discrete(name = "Time_Period") +  # Customize legend title
  labs(x = "Time_Period", y = "Count", title = " Incident Count of Time_Period") +
  theme(legend.position = "none")  # Hide legend (optional)
```

```{r}
data2_filled_updated1$Time_Period <- as.factor(data2_filled_updated1$Time_Period)
```

```{r}
# GROUPING 'MIN DELAY' DATA FOR FUTURE ANALYSIS

data2_filled_updated1 <- data2_filled_updated %>%
  mutate(Delay_Severity = case_when(
    `Min_Delay_Winsorized` >= 0 & `Min_Delay_Winsorized` <= 5 ~ "Borderline Late",
    `Min_Delay_Winsorized` >= 6 & `Min_Delay_Winsorized` <= 10 ~ "Slightly Late",
    `Min_Delay_Winsorized` >= 11 & `Min_Delay_Winsorized` <= 20 ~ "Considerably Late",
    `Min_Delay_Winsorized` >= 21 & `Min_Delay_Winsorized` <= 30 ~ "Very Late",
    `Min_Delay_Winsorized` > 30 ~ "Extremely Late",
    TRUE ~ "On Time"  # Handle cases where Min Delay is negative or other values
  ))
data2_filled_updated1$Delay_Severity <- as.factor(data2_filled_updated1$Delay_Severity)

# Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled_updated1, aes(x = Delay_Severity, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Delay_Severity", y = "Min Delay", title = "Boxplot of Min Delay by Delay_Severity")
```

```{r}
# Reducing Incident Row labels from 12 to 5 
data2_filled_updated2 <- data2_filled_updated1 %>%
  mutate(Incident = recode(Incident,
                            "Cleaning" = "Weather n' General Delay",
                            "Collision" = "Road Collision n' Emergencies",
                            "Diversion" = "Road Collision n' Emergencies",
                            "Emergency Services" = "Security Intervention",
                            "General Delay" = "Weather n' General Delay",
                            "Investigation" = "Security Intervention",
                            "Management" = "Weather n' General Delay",
                            "Mechanical" = "Mechanical issue",
                            "Operations" = "Maintenance n' Operations",
                            "Overhead" = "Weather n' General Delay",
                            "Security" = "Security Intervention",
                            "Vision" = "Weather n' General Delay"
                            ))
```

```{r}
library(dplyr)
library(ggplot2)
library(forcats)  # Load the forcats package for fct_reorder

# Calculate the count of each incident
incident_counts <- data2_filled_updated2 %>%
  count(Incident) %>%
  arrange(desc(n))  # Arrange in descending order of frequency

# Create a ggplot with multiple colors, data labels, and ordered incident types
ggplot(incident_counts, aes(x = fct_reorder(Incident, n), y = n, fill = Incident)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = n), vjust = -0.5, size = 3) +  # Add data labels
  labs(title = "Histogram of Incidents", x = "Incident", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels
  scale_fill_manual(values = rainbow(length(incident_counts$Incident)))  # Use multicolor
```

```{r}
# Perform k-means clustering
set.seed(123)  # Set seed for reproducibility
k <- 5  # Number of clusters
kmeans_result <- kmeans(data2_filled_updated2$`Min_Delay_Winsorized`, centers = k)

# Add cluster labels to the original data
data2_filled_updated2$cluster <- as.factor(kmeans_result$cluster)

# Visualize the clusters
library(ggplot2)
ggplot(data2_filled_updated2, aes(x = Incident, y = `Min_Delay_Winsorized`, color = cluster)) +
  geom_point(position = position_jitter(width = 0.3), size = 2) +
  labs(x = "Incident", y = "Min Delay", title = "Clustering of Incidents based on Min Delay") +
  scale_color_discrete(name = "Cluster") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```

```{r}
data2_filled_updated2$Time_Period <- as.factor(data2_filled_updated2$Time_Period)
```

```{r}
str(data2_filled_updated2)
```

```{r}
subset_data2_filled_updated2<-data2_filled_updated2[,c("Day","Delay_Severity")]
plot(subset_data2_filled_updated2)
```

```{r}
# Install and load ggcorrplot package if not already installed
install.packages("ggcorrplot")
library(ggcorrplot)
```

```{r}
library(dplyr)
numeric_data1 <- data2_filled_updated2
numeric_data1$Time_Period<-as.numeric(numeric_data1$Time_Period)
numeric_data1$Delay_Severity<-as.numeric(numeric_data1$Delay_Severity)
numeric_data1$Incident<-as.numeric(numeric_data1$Incident)
numeric_data1$Day<-as.numeric(numeric_data1$Day)

# Select numeric variables
numeric_data <- numeric_data1 %>%
  select_if(is.numeric)

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data)

# Plot the correlation matrix using ggcorrplot
ggcorrplot(correlation_matrix, hc.order = TRUE, type = "lower", lab = TRUE)




```

```{r}
str(data2_filled_updated2)
```

```{r}
library(dplyr)
library(ggplot2)
library(lubridate)

# Extract the month name from the Date column
data2_filled_updated2$Month_Name <- month(data2_filled_updated2$Date, label = TRUE, abbr = FALSE)

# Aggregate count by month name
incidents_by_month_name <- data2_filled_updated2 %>%
  group_by(Month_Name) %>%
  summarise(Total_Incidents = n()) %>%
  mutate(Month_Name = reorder(Month_Name, -Total_Incidents)) # Reorder based on total incidents in descending order

# Plot the total number of incidents by month with month names in descending order
ggplot(incidents_by_month_name, aes(x = Month_Name, y = Total_Incidents)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = Total_Incidents), vjust = -0.3, size = 3.5) +
  labs(title = "Total Number of Incidents by Month", x = "Month", y = "Total Incidents") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotate the x-axis labels for better readability

# Print the plot
print(ggplot(incidents_by_month_name))

```

```{r}
# MONTHWISE AVERAGE DELAY 
# Load required libraries
library(dplyr)
library(ggplot2)

# Convert Date column to year-month format
data2_filled_updated2$Month <- format(data2_filled_updated2$Date, "%m")

# Aggregate data by month and calculate the mean Min Delay for each month
data_by_month <- data2_filled_updated2 %>%
  group_by(Month) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Convert month numbers to month names
data_by_month$Month <- factor(month.name[as.numeric(data_by_month$Month)], levels = month.name)

# Reorder levels of Month according to Avg_Min_Delay in descending order
data_by_month <- data_by_month %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Month = factor(Month, levels = Month))

# Create bar plot
ggplot(data_by_month, aes(x = Month, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "skyblue") +  # Bar plot
  geom_text(aes(label = round(Avg_Min_Delay, 2)), vjust = -0.5, color = "black", size = 3) +  # Add data labels
  labs(title = "Average Min Delay by Month",
       x = "Month",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

```

```{r}
# Load necessary libraries
library(dplyr)
library(lubridate)

# Extract month from the Date column and count incidents for each month
month_wise_incident_counts <- data2_filled_updated2 %>%
  mutate(Month = month(Date, label = TRUE)) %>%
  count(Month) %>%
  mutate(Percentage = n / sum(n) * 100) %>%
  arrange(Month)

# Print the month-wise counts and percentages
print(month_wise_incident_counts)
```

```{r}
library(dplyr)
library(ggplot2)

# AVERAGE DELAY BY INCIDENT

# Aggregate data by incident and calculate the mean Min Delay for each incident
data_by_incident <- data2_filled_updated2 %>%
  group_by(Incident) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Incident according to Avg_Min_Delay in descending order
data_by_incident <- data_by_incident %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Incident = factor(Incident, levels = Incident))

# Create bar plot
ggplot(data_by_incident, aes(x = Incident, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "lightgreen") +  # Bar plot with different color
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Add data labels in the middle of the bars
  labs(title = "Average Delay by Incident",
       x = "Incident",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```
```{r}
subset_data2_filled_updated2<-data2_filled_updated2[,c("Incident","Delay_Severity")]
plot(subset_data2_filled_updated2)
```
```{r}

```

```{r}
# Assuming your tibble is named "data_tibble"

# Aggregate data by time period and calculate the mean Min Delay for each time period
data_by_time_period <- data2_filled_updated2 %>%
  group_by(Time_Period) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Time_Period according to Avg_Min_Delay in descending order
data_by_time_period <- data_by_time_period %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Time_Period = factor(Time_Period, levels = Time_Period))

# Create bar plot
ggplot(data_by_time_period, aes(x = Time_Period, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "lightblue") +  # Bar plot with different color
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Add data labels in the middle of the bars
  labs(title = "Average Delay by Time Period",
       x = "Time Period",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```
```{r}
# Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled_updated2, aes(x = Time_Period, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Time_Period", y = "Min Delay", title = "Boxplot of Min Delay by Time_Period")
```

```{r}
# Assuming your tibble is named "data_tibble"

# Aggregate data by day and calculate the mean Min Delay for each day
data_by_day <- data2_filled_updated2 %>%
  group_by(Day) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Day according to Avg_Min_Delay in descending order
data_by_day <- data_by_day %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Day = factor(Day, levels = Day))

# Create bar plot
ggplot(data_by_day, aes(x = Day, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "lightgreen") +  # Bar plot with different color
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Add data labels in the middle of the bars
  labs(title = "Average Delay by Day",
       x = "Day",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.major = element_blank(), panel.grid.minor = element_blank())  # Rotate x-axis labels for better readability and remove gridlines
```

```{r}
library(dplyr)
library(ggplot2)

# Assuming your tibble is named "data_tibble"

# Filter data for weekends (Saturday and Sunday) and weekdays
weekends <- data2_filled_updated2 %>%
  filter(Day %in% c("Saturday", "Sunday"))
weekdays <- data2_filled_updated2 %>%
  filter(Day %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))

# Perform t-test to compare average delays between weekends and weekdays
t_test_result <- t.test(weekends$`Min_Delay_Winsorized`, weekdays$`Min_Delay_Winsorized`, alternative = "greater", conf.level = 0.99)
# Print the result
print(t_test_result)
#This suggests that there is a statistically significant difference in average delays between weekends and weekdays. The 95% confidence interval for the difference in means ranges from 0.9767709 to infinity.based on the very small p-value (significantly less than any reasonable significance level such as 0.05), we can reject the null hypothesis

#The sample estimates indicate that the mean delay for weekends (21.16196) is higher than the mean delay for weekdays (19.68358).
```

```{r}
# Calculate average delays for weekends and weekdays
average_delay_weekends <- mean(weekends$`Min_Delay_Winsorized`)
average_delay_weekdays <- mean(weekdays$`Min_Delay_Winsorized`)

# Create a bar plot to visualize the average delays between weekends and weekdays
average_delays <- data.frame(
  Day = c("Weekends", "Weekdays"),
  Average_Delay = c(average_delay_weekends, average_delay_weekdays)
)

# Bar plot with data labels
ggplot(average_delays, aes(x = Day, y = Average_Delay, fill = Day)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.1f", Average_Delay)), vjust = -0.5, size = 3.5, color = "black") +  # Add data labels
  labs(x = "Day", y = "Average Delay", title = "Average Delay Between Weekends and Weekdays") +
  theme_minimal()
```

```{r}
# Extract the year from the Date column
data2_filled_updated2 <- mutate(data2_filled_updated2, Year = lubridate::year(Date))

# Calculate average Min. Delay for each year
average_delay <- data2_filled_updated2 %>%
  group_by(Year) %>%
  summarize(Avg_Delay = mean(`Min_Delay_Winsorized`))

# Plot the trend
ggplot(average_delay, aes(x = Year, y = Avg_Delay)) +
  geom_line() +
  geom_point() +
  labs(title = "Trend of Average Min. Delay Over the Years",
       x = "Year",
       y = "Average Min. Delay") +
  theme_minimal()

```

```{r}
# Filter data for years 2021, 2022, and 2023
filtered_data <- data2_filled_updated2 %>%
  filter(Year %in% c(2021, 2022, 2023))

# Count incidents for each year
incident_count <- filtered_data %>%
  group_by(Year, Incident) %>%
  summarize(Count = n())

# Plot the trend
ggplot(incident_count, aes(x = Year, y = Count, color = Incident)) +
  geom_line() +
  geom_point() +
  labs(title = "Trend of Total Incidents Over the Years",
       x = "Year",
       y = "Total Incidents",
       color = "Incident Type") +
  theme_minimal()
```

```{r}
# Filter data for years 2021, 2022, and 2023
filtered_data <- data2_filled_updated2 %>%
  filter(Year %in% c(2021, 2022, 2023))

# Count total incidents for each year
incident_count <- filtered_data %>%
  group_by(Year) %>%
  summarize(Total_Incidents = n())

# Plot the trend
ggplot(incident_count, aes(x = Year, y = Total_Incidents)) +
  geom_line() +
  geom_point() +
  labs(title = "Trend of Total Incidents Over the Years",
       x = "Year",
       y = "Total Incidents") +
  theme_minimal()
```

```{r}
# Aggregate data by route and calculate the mean Min Delay for each route
data_by_route <- data2_filled_updated2 %>%
  group_by(Route) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Route according to Avg_Min_Delay in descending order
data_by_route <- data_by_route %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Route = factor(Route, levels = Route))

# Select the top 25 routes with the highest average minimum delay
top_routes <- head(data_by_route, 20)

# Create bar plot for the top 20 routes
ggplot(top_routes, aes(x = reorder(Route, Avg_Min_Delay), y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = ifelse(rank(-top_routes$Avg_Min_Delay) %% 2 == 0, "lightblue", "lightgreen")) +  # Alternating bar colors
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_dodge(width = 0.9), vjust = -0.5, color = "black", size = 3) +  # Add data label above bars
  coord_flip() +  # Flip coordinates for horizontal bar chart
  labs(title = "Top 20 Routes with Highest Average Min Delay",
       x = "Route",
       y = "Average Min Delay") +
  theme_minimal()
```

```{r}
# Aggregate data by route and calculate the mean Min Delay for each route
data_by_location <- data2_filled_updated2 %>%
  group_by(Location) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Route according to Avg_Min_Delay in descending order
data_by_location <- data_by_location %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Location = factor(Location, levels = Location))

# Select the top 25 routes with the highest average minimum delay
top_location <- head(data_by_location, 20)

# Create bar plot for the top 20 routes
ggplot(top_location, aes(x = reorder(Location, Avg_Min_Delay), y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = ifelse(rank(-top_location$Avg_Min_Delay) %% 2 == 0, "lightblue", "lightgreen")) +  # Alternating bar colors
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_dodge(width = 0.9), vjust = -0.5, color = "black", size = 3) +  # Add data label above bars
  coord_flip() +  # Flip coordinates for horizontal bar chart
  labs(title = "Top 20 Location with Highest Average Min Delay",
       x = "Location",
       y = "Average Min Delay") +
  theme_minimal()
```

```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)

# Aggregate data to count the number of incidents per location
incident_counts <- data2_filled_updated2 %>%
  group_by(Location) %>%
  summarise(Incidents = n()) %>%
  arrange(desc(Incidents)) %>%
  top_n(20, Incidents)

# Plot the top 20 locations with the highest number of incidents, including data labels
ggplot(incident_counts, aes(x = reorder(Location, Incidents), y = Incidents)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = Incidents), position = position_stack(vjust = 0.5), color = "white") +
  coord_flip() + # Flip the coordinates to make it a horizontal bar plot
  labs(title = "Top 20 Locations with Highest Number of Incidents",
       x = "Location",
       y = "Number of Incidents") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Improve label readability

# Display the plot
ggsave("Top20_Locations_Incidents_with_Labels.png", width = 10, height = 8, dpi = 300)

```

```{r}
# CHECK FOR DATA IMBALANCE
library(dplyr)

# Count the frequency of each level in the 'Incident' column and calculate percentage
incident_balance <- data2_filled_updated2 %>%
  count(Incident) %>%
  mutate(Percentage = n / sum(n) * 100) %>%
  arrange(desc(n))

# Print the counts and percentages to check for imbalance
print(incident_balance)

```
```{r}
str(data2_filled_updated2)
```

```{r}
summary(lm (Min_Delay_Winsorized ~ Incident + Time_Period + Route + Day + Direction , data = data2_filled_updated2 ))
```
