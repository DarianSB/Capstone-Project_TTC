---
title: "CAPSTONE Project _TTC DELAY ANALYSIS AND PREDICTION"
output:
  html_document: default
  pdf_document: default
date: "2024-02-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

#INITIAL ANALYSIS OF TTC DELAY DATASET:

```{r}
# Load the TTC Delay data readxl package:
library(readxl)

# Read the Excel file
data2 <- read_excel("ttc-bus-delay-data-2021-23.xlsx")

```

```{r}
str(data2)
```

```{r}
summary(data2)
```
#ASSIGNING CORRECT DATA TYPE:
```{r}
data2$Day <- as.factor(data2$Day)
data2$Incident <- as.factor(data2$Incident)
data2$Direction <- as.factor(data2$Direction)
str(data2)
```
#IDENTIFYING PRESENCE OF 'MISSING VALUES' IN THE TTC DATASET:
```{r}
# Identifying Presence of Missing Data
missing_values <- colSums(is.na(data2))

# Print the count of missing values for each column
print(missing_values)
```
#HANDLING MISSING VALUES:
```{r}
#Subsetting rows where route is not provided
data2 <- subset(data2, !is.na(Route))
library(DescTools)
library(dplyr)

# Replacing Direction attibutes with NA values based on route and its corresponding mode of direction
data2_filled <- data2 %>%
  group_by(Route) %>%
  mutate(Direction = ifelse(is.na(Direction), Mode(as.integer(Direction), na.rm = TRUE), Direction)) %>%
  ungroup()
missing_values <- colSums(is.na(data2_filled))

# Print the count of missing values for each column
print(missing_values)
```
#IDENTIFYING PRESENCE OF OUTLIERS IN  DEPENDENT VARIABLE 'MIN DELAY' ACROSS INCIDENT TYPES:
```{r}
# Load the ggplot2 package
library(ggplot2)

# OUTLIER ANALYSIS: Boxplot to clearly see the interquartile range
ggplot(data2_filled, aes(x = Incident, y = `Min Delay`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Incident", y = "Min Delay", title = "Boxplot of Min Delay by Incident")

```
#PERFORMING 'WINSORIZATION' TO FIX OUTLIERS IN DEPENDENT VARIABLE 'MIN DELAY': 
```{r}
# Perform 'Winsorization' to Fix Outlier Issues: capping the outliers at a certain percentile. For example, all data points above the 94th percentile and below the 2th percentile
library(DescTools)

# Winsorize the 'Min Delay' column at the 2ND and 94th percentiles for the entire data
data2_filled$Min_Delay_Winsorized <- Winsorize(data2_filled$`Min Delay`, probs = c(0.02, 0.94))

# Check the results
summary(data2_filled$Min_Delay_Winsorized)
```

# BOXPLOT OF 'MIN DELAY' DATA ACROSS INCIDENT TYPES POST WINSORIZATION
```{r}
library(ggplot2)
# OUTLIER ANALYSIS: Boxplot to clearly see the interquartile range
ggplot(data2_filled, aes(x = Incident, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Incident", y = "Min Delay", title = "Boxplot of Min Delay by Incident")
```
#GROUPING 'MIN DELAY' DEPENDENT VARIABLE TO CHECK DATA IMBALANCE
```{r}
# GROUPING 'MIN DELAY' DATA FOR FUTURE ANALYSIS

data2_filled_updated <- data2_filled %>%
  mutate(Delay_Severity = case_when(
    `Min_Delay_Winsorized` >= 0 & `Min_Delay_Winsorized` < 5 ~ "<5 Min",
    `Min_Delay_Winsorized` >= 5 & `Min_Delay_Winsorized` <= 10 ~ "5-10 Min",
    `Min_Delay_Winsorized` >10 & `Min_Delay_Winsorized` <= 15 ~ "11-15 Min",
    `Min_Delay_Winsorized` >15 & `Min_Delay_Winsorized` <= 20 ~ "16-20 Min",
    `Min_Delay_Winsorized` > 20 ~ ">20 Min",
    TRUE ~ "On Time"  # Handle cases where Min Delay is negative or other values
  ))
data2_filled_updated$Delay_Severity <- as.factor(data2_filled_updated$Delay_Severity)

# CHECK FOR DATA IMBALANCE
library(dplyr)

# Count the frequency of each level in the 'Incident' column and calculate percentage
Delay_Severity_balance <- data2_filled_updated %>%
  count(Delay_Severity) %>%
  mutate(Percentage = n / sum(n) * 100) %>%
  arrange(desc(n))

# Print the counts and percentages to check for imbalance
print(Delay_Severity_balance)

```

#BAR GRAPH OF 'DELAY_SEVERITY' DEPENDENT VARIABLE TO CHECK DATA IMBALANCE
```{r}
#COUNT OF INCIDENTS
library(ggplot2)

# Create a bar graph with data labels and different bar colors
ggplot(data2_filled_updated, aes(x = Delay_Severity, fill = Delay_Severity)) +
  geom_bar() +
  geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) +  # Add data labels
  scale_fill_discrete(name = "Delay_Severity") +  # Customize legend title
  labs(x = "Delay_Severity", y = "Count", title = "Count of Delay_Severity") +
  theme(legend.position = "none")  # Hide legend (optional)

```
#REDUCING NUMBER OF CLASS/LEVELS WITHIN TARGET VARIABLE FROM 5 TO 3 TO ADDRESS DATA IMBALANCE:
```{r}
#REGROUPING 'DELAY_SEVERITY' DATA FOR EASE OF CLASSIFICATION

data2_filled_updated1 <- data2_filled_updated %>%
  mutate(Delay_Severity = case_when(
    `Min_Delay_Winsorized` >= 0 & `Min_Delay_Winsorized` < 10 ~ "Borderline Late (<10 Min)",
    `Min_Delay_Winsorized` >=10 & `Min_Delay_Winsorized` <= 15 ~ "Considerably Late (11-15 Min)",
    `Min_Delay_Winsorized` > 15 ~ "Extremely Late (>15 Min)",
    TRUE ~ "On Time"  # Handle cases where Min Delay is negative or other values
  ))
data2_filled_updated1$Delay_Severity <- as.factor(data2_filled_updated1$Delay_Severity)

# Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled_updated1, aes(x = Delay_Severity, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Delay_Severity", y = "Min Delay", title = "Boxplot of Min Delay by Delay_Severity")
```

#DISTRIBUTION OF DELAY INCIDENCE ACROSS 3 CLASSES OF 'DELAY_SEVERITY' TARGET VARIABLE:
```{r}
# CHECK FOR DATA IMBALANCE
library(dplyr)

# Count the frequency of each level in the 'Incident' column and calculate percentage
Delay_Severity_balance1 <- data2_filled_updated1 %>%
  count(Delay_Severity) %>%
  mutate(Percentage = n / sum(n) * 100) %>%
  arrange(desc(n))

# Print the counts and percentages to check for imbalance
print(Delay_Severity_balance1)
```
#ADDRESSING CATEGORICAL VARIABLES WITH EXCESSIVE LABELS:

#'INCIDENT' VARAIBELE WITH 12 LABELS
```{r}
# Load necessary library
library(dplyr)

# Count incidents for each type and calculate the percentage of the grand total
incident_type_counts <- data2_filled_updated1 %>%
  group_by(Incident) %>%
  summarise(IncidentCount = n(), .groups = 'drop') %>%
  mutate(TotalIncidents = sum(IncidentCount), # Calculate the total number of incidents
         PercentageOfTotal = IncidentCount / TotalIncidents * 100) %>%
  arrange(desc(IncidentCount)) # Arrange by descending order of incident counts

# Print the results
print(incident_type_counts)
```
# REDUCING 'INCIDENT' LABELS FROM 12 TO 4:
```{r}
data2_filled_updated2 <- data2_filled_updated1 %>%
  mutate(Incident = recode(Incident,
                            "Cleaning" = "General Delay n' Weather",
                            "Collision" = "Accidents n' Emergencies",
                            "Diversion" = "General Delay n' Weather",
                            "Emergency Services" = "Accidents n' Emergencies",
                            "General Delay" = "General Delay n' Weather",
                            "Investigation" = "Accidents n' Emergencies",
                            "Management" = "General Delay n' Weather",
                            "Mechanical" = "Mechanical issue",
                            "Operations" = "Maintenance Operations",
                            "Overhead" = "General Delay n' Weather",
                            "Security" = "Accidents n' Emergencies",
                            "Vision" = "General Delay n' Weather"
                            ))
```
```{r}
# Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled_updated2, aes(x = Incident, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Incident", y = "Min Delay", title = "Boxplot of Min Delay by Incident")
```
```{r}
library(dplyr)
library(ggplot2)
library(forcats)  # Load the forcats package for fct_reorder

# Calculate the count of each incident
incident_counts <- data2_filled_updated2 %>%
  count(Incident) %>%
  arrange(desc(n))  # Arrange in descending order of frequency

# Create a ggplot with multiple colors, data labels, and ordered incident types
ggplot(incident_counts, aes(x = fct_reorder(Incident, n), y = n, fill = Incident)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = n), vjust = -0.5, size = 3) +  # Add data labels
  labs(title = "Histogram of Incidents", x = "Incident", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels
  scale_fill_manual(values = rainbow(length(incident_counts$Incident)))  # Use multicolor
```

# GROUPING 'TIME' VARIABLE ACROSS 4 TIME-PERIODS:
```{r}
library(dplyr)

data2_filled_updated2 <- data2_filled_updated2 %>%
  mutate(Hour = as.integer(substr(Time, 1, 2)),
         Minute = as.integer(substr(Time, 4, 5)),
         Time_Period = case_when(
           (Hour == 6 & Minute >= 0) | (Hour > 6 & Hour < 10) ~ "Morning Peak Hours (6-10)",
           (Hour == 10 & Minute >= 0) | (Hour > 10 & Hour < 13) ~ "Morning Off-Peak Hours (10-13)",
           (Hour == 13 & Minute >= 0) | (Hour > 13 & Hour < 16) ~ "Afternoon Off-Peak Hours (13-16)",
           (Hour == 16 & Minute >= 0) | (Hour > 16 & Hour < 19) ~ "Afternoon Peak Hours (16-19)",
           (Hour == 19 & Minute >= 0) | (Hour > 19 & Hour < 22) ~ "Evening Hours (19-22)",
           (Hour == 23 & Minute >= 0) | (Hour > 23 & Hour < 1) ~ "Midnight Hours (22-1)",
           TRUE ~ "Late Night Hours (1-6)"
         ))
data2_filled_updated2 <- data2_filled_updated2 %>%
  select(-c(Hour, Minute))  # Remove the "Hour" and "Minute" columns

library(ggplot2)

# Reorder the levels of Time_Period based on count of incidents
data2_filled_updated2$Time_Period <- factor(data2_filled_updated2$Time_Period, 
                                            levels = names(sort(table(data2_filled_updated2$Time_Period), decreasing = TRUE)))

# Plotting with ggplot
ggplot(data2_filled_updated2, aes(x = Time_Period, fill = Time_Period)) +
  geom_bar() +
  geom_text(stat = 'count', aes(label = ..count..), vjust = -0.5) +  
  scale_fill_discrete(name = "Time_Period") +  
  labs(x = "Time_Period", y = "Count", title = "Incident Count of Time_Period") +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
data2_filled_updated2$Time_Period <- as.factor(data2_filled_updated2$Time_Period)
```


```{r}
# Aggregate data by time period and calculate the mean Min Delay for each time period
data_by_time_period <- data2_filled_updated2 %>%
  group_by(Time_Period) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Time_Period according to Avg_Min_Delay in descending order
data_by_time_period <- data_by_time_period %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Time_Period = factor(Time_Period, levels = Time_Period))

# Create bar plot
ggplot(data_by_time_period, aes(x = Time_Period, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "lightblue") +  # Bar plot with different color
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Add data labels in the middle of the bars
  labs(title = "Average Delay by Time Period",
       x = "Time Period",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```
```{r}
# Create a customized boxplot to clearly see the interquartile range
ggplot(data2_filled_updated2, aes(x = Time_Period, y = `Min_Delay_Winsorized`)) +
  geom_boxplot(coef = 1.5) +  # Adjust the coef parameter to control the length of the whiskers
  labs(x = "Time_Period", y = "Min Delay", title = "Boxplot of Min Delay by Time_Period")
```


# MONTH-WISE DELAY INCIDENTS:
```{r}
library(dplyr)
library(ggplot2)
library(lubridate)

# Extract the month name from the Date column
data2_filled_updated2$Month_Name <- month(data2_filled_updated2$Date, label = TRUE, abbr = FALSE)

# Aggregate count by month name
incidents_by_month_name <- data2_filled_updated2 %>%
  group_by(Month_Name) %>%
  summarise(Total_Incidents = n()) %>%
  mutate(Month_Name = reorder(Month_Name, -Total_Incidents)) # Reorder based on total incidents in descending order


# Extract month from the Date column and count incidents for each month
month_wise_incident_counts <- data2_filled_updated2 %>%
  mutate(Month = month(Date, label = TRUE)) %>%
  count(Month) %>%
  mutate(Percentage = n / sum(n) * 100) %>%
  arrange(Month)

# Print the month-wise counts and percentages
print(month_wise_incident_counts)
```

# AVERAGE 'MIN DELAY' ACROSS MONTHS:
```{r}
# MONTHWISE AVERAGE DELAY 
# Load required libraries
library(dplyr)
library(ggplot2)

# Convert Date column to year-month format
data2_filled_updated2$Month <- format(data2_filled_updated2$Date, "%m")

# Aggregate data by month and calculate the mean Min Delay for each month
data_by_month <- data2_filled_updated2 %>%
  group_by(Month) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Convert month numbers to month names
data_by_month$Month <- factor(month.name[as.numeric(data_by_month$Month)], levels = month.name)

# Reorder levels of Month according to Avg_Min_Delay in descending order
data_by_month <- data_by_month %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Month = factor(Month, levels = Month))

# Create bar plot
ggplot(data_by_month, aes(x = Month, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "skyblue") +  # Bar plot
  geom_text(aes(label = round(Avg_Min_Delay, 2)), vjust = -0.5, color = "black", size = 3) +  # Add data labels
  labs(title = "Average Min Delay by Month",
       x = "Month",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

```
# AVERAGE DELAY BY INCIDENT:
```{r}
library(dplyr)
library(ggplot2)

# Aggregate data by incident and calculate the mean Min Delay for each incident
data_by_incident <- data2_filled_updated2 %>%
  group_by(Incident) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Incident according to Avg_Min_Delay in descending order
data_by_incident <- data_by_incident %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Incident = factor(Incident, levels = Incident))

# Create bar plot
ggplot(data_by_incident, aes(x = Incident, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "lightgreen") +  # Bar plot with different color
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Add data labels in the middle of the bars
  labs(title = "Average Delay by Incident",
       x = "Incident",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```
# AVERAGE DELAY BY DAY
```{r}
# Aggregate data by day and calculate the mean Min Delay for each day
data_by_day <- data2_filled_updated2 %>%
  group_by(Day) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Day according to Avg_Min_Delay in descending order
data_by_day <- data_by_day %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Day = factor(Day, levels = Day))

# Create bar plot
ggplot(data_by_day, aes(x = Day, y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = "lightblue") +  # Bar plot with different color
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_stack(vjust = 0.5), color = "black", size = 3) +  # Add data labels in the middle of the bars
  labs(title = "Average Delay by Day",
       x = "Day",
       y = "Average Min Delay") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.major = element_blank(), panel.grid.minor = element_blank())  # Rotate x-axis labels for better readability and remove gridlines
```

# TOP 20 ROUTES WITH HIGHEST DELAY INCIDENT
```{r}
# Aggregate data by route and calculate the mean Min Delay for each route
data_by_route <- data2_filled_updated2 %>%
  group_by(Route) %>%
  summarise(Avg_Min_Delay = mean(`Min_Delay_Winsorized`))

# Reorder levels of Route according to Avg_Min_Delay in descending order
data_by_route <- data_by_route %>%
  arrange(desc(Avg_Min_Delay)) %>%
  mutate(Route = factor(Route, levels = Route))

# Select the top 25 routes with the highest average minimum delay
top_routes <- head(data_by_route, 20)

# Create bar plot for the top 20 routes
ggplot(top_routes, aes(x = reorder(Route, Avg_Min_Delay), y = Avg_Min_Delay)) +
  geom_bar(stat = "identity", fill = ifelse(rank(-top_routes$Avg_Min_Delay) %% 2 == 0, "lightblue", "lightgreen")) +  # Alternating bar colors
  geom_text(aes(label = round(Avg_Min_Delay, 2)), position = position_dodge(width = 0.9), vjust = -0.5, color = "black", size = 3) +  # Add data label above bars
  coord_flip() +  # Flip coordinates for horizontal bar chart
  labs(title = "Top 20 Routes with Highest Average Min Delay",
       x = "Route",
       y = "Average Min Delay") +
  theme_minimal()
```

# TOP 20 LOCATION WITH HIGHEST DELAY INCIDENCE
```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)

# Aggregate data to count the number of incidents per location
incident_counts <- data2_filled_updated2 %>%
  group_by(Location) %>%
  summarise(Incidents = n()) %>%
  arrange(desc(Incidents)) %>%
  top_n(20, Incidents)

# Plot the top 20 locations with the highest number of incidents, including data labels
ggplot(incident_counts, aes(x = reorder(Location, Incidents), y = Incidents)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = Incidents), position = position_stack(vjust = 0.5), color = "white") +
  coord_flip() + # Flip the coordinates to make it a horizontal bar plot
  labs(title = "Top 20 Locations with Highest Number of Incidents",
       x = "Location",
       y = "Number of Incidents") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Improve label readability

# Display the plot
ggsave("Top20_Locations_Incidents_with_Labels.png", width = 10, height = 8, dpi = 300)

```

# WINSORIZATION OF 'MIN GAP' VARIABLE
```{r}
# Perform 'Winsorization' to Fix Outlier Issues: capping the outliers at a certain percentile. For example, all data points above the 95th percentile and below the 5th percentile
library(DescTools)

# Winsorize the 'Min Delay' column at the 5th and 95th percentiles for the entire data
data2_filled_updated2$Min_Gap_Winsorized <- Winsorize(data2_filled_updated2$`Min Gap`, probs = c(0.02, 0.95))

# Check the results
summary(data2_filled_updated2$Min_Gap_Winsorized)
```

```{r}
numeric_data1 <- data2_filled_updated2
str(numeric_data1)
```

# CORRELATION ANALYSIS OF VARIABLES
```{r}
library(ggcorrplot)
library(dplyr)
numeric_data1$Time_Period<-as.numeric(numeric_data1$Time_Period)
numeric_data1$Delay_Severity<-as.numeric(numeric_data1$Delay_Severity)
numeric_data1$Incident<-as.numeric(numeric_data1$Incident)
numeric_data1$Day<-as.numeric(numeric_data1$Day)
numeric_data1$Month_Name<-as.numeric(numeric_data1$Month_Name)
numeric_data1$Direction<-as.numeric(numeric_data1$Direction)

numeric_data1 <- numeric_data1 %>%
  select(-`Min Delay`, -`Min Gap`)

```


```{r}
# Select numeric variables
numeric_data <- numeric_data1 %>%
  select_if(is.numeric)

# Calculate the correlation matrix
correlation_matrix <- cor(numeric_data)

# Plot the correlation matrix using ggcorrplot
ggcorrplot(correlation_matrix, hc.order = TRUE, type = "lower", lab = TRUE)
```

```{r}
summary(lm (Min_Delay_Winsorized ~ Incident + Time_Period + Route + Day + Direction , data = data2_filled_updated2 ))
```


```{r}
Cleaned_Data<-data2_filled_updated2
Cleaned_Data$Time_Period<- as.integer(Cleaned_Data$Time_Period)
Cleaned_Data$Incident<- as.numeric(Cleaned_Data$Incident)
Cleaned_Data$Day<- as.numeric(Cleaned_Data$Day)
str(Cleaned_Data)
```


```{r}
library(class)
library(gmodels)
round(prop.table(table(Cleaned_Data$Incident))*100,digits = 1)
```


```{r}
normalize<-function(x){return((x-min(x))/(max(x)-min(x)))}
```


```{r}
normalized<-as.data.frame(lapply(Cleaned_Data[c(3,5,7,10,11,14)],normalize))
```


```{r}
Preprocessed_dataset<-cbind(Cleaned_Data$Delay_Severity,normalized)
str(Preprocessed_dataset)
```


```{r}

```

